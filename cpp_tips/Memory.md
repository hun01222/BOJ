## 음수의 표현

### 부호 비트와 절댓값 방법

* 최상위 1비트로 부호 표현, 나머지 비트로 해당 정수 절댓값 표현
* +0과 -0이 동시에 존재하는 문제

### 1의 보수법 (ones' complement)

* 해당 양수의 모든 비트를 반전(not 연산)하여 음수 표현
* +0과 -0이 동시에 존재하는 문제

### 2의 보수법 (twos' complement)

* 해당 양수의 모든 비트를 반전한 후 1을 더해 음수 표현
* -0의 경우 최상위 비트를 초과한 오버플로우 발생 +0만 존재하게 됨


## 실수의 표현

### 고정 소수점 방식 (fixed point)

* 32비트 기준 부호(1비트), 정수부(15비트), 소수부(16비트)
* 표현할 수 있는 범위가 매우 적음

### 부동 소수점 방식 (floating point)

* 가수부와 지수부로 나누어 표현
* 매우 큰 실수까지도 표현 가능
* but, 부동소수점 방식은 항상 오차 존재

$\pm (1.base)\times 2^exp-127 $

#### IEEE 부동 소수점 방식

* float형 부호(1비트), 지수부(8비트), 가수부(23비트)
* double형 부호(1비트), 지수부(11비트), 가수부(64비트)


## 메모리의 구조

(낮은 주소) **코드 영역**: 실행할 프로그램의 코드 (프로그램 시작과 함께 할당, 종료 시 소멸)| **데이터 영역**: 전역 변수, 정적 변수 | **힙 영역**: 사용자의 동적 할당 (런 타임의 크기가 결정됨) | **스택 영역**: 지역 변수, 매개 변수 (컴파일 타임의 크기가 결정됨) (높은 주소)

### 스택 프레임

* 스택 영역에 차례대로 저장되는 함수의 호출 정보
* 함수의 호출과 함께 할당, 함수의 호출이 완료되면 소멸

### 스택 오버플로우

* 스택 영역을 넘어가서 저장되는 경우

### 메모리의 동적 할당

* 컴파일 타임에 데이터 영역과 스택 영역에 할당되는 메모리의 크기는 결정됨
* 런 타임에 힙 영역의 크기를 사용자가 직접 결정함


## 변수의 유효 범위

|변수 종류|메모리 소멸 시기|초깃값|저장 장소|비고|
|:--|:--|:--|:--|:--|
|지역 변수|함수 종료 시|초기화되지 않음|스택 영역|
|전역 변수|프로그램 종료 시|0으로 초기화됨|데이터 영역|
|정적 변수|프로그램 종료 시|0으로 초기화됨|데이터 영역|함수 블록의 내부|
|레지스터 변수|함수 종료 시|초기화되지 않음|레지스터|빠르게 접근 가능, 함수 블록의 내부|


## 콘솔 입출력

 * 표준 입출력 함수를 사용할 때에는 버퍼라는 임시 메모리 공간을 사용
 * 문자를 묶어서 전달하므로 전송 시간 절약, 사용자가 문자를 잘 못 입력했을 경우 수정 가능
 * 버퍼링의 방식
 	* 완전 버퍼링: 버퍼가 가득 차면 버퍼 안의 내용을 목적지로 보냄
	* 라인 버퍼링: 개행 문자가 나타날 때마다 버퍼 안의 내용을 목적지로 보냄